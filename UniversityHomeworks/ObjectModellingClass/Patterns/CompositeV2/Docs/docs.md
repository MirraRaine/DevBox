# Composite Design Pattern - Drawing

The **Composite Design Pattern** allows you to compose objects into tree structures to represent part-whole hierarchies. It lets clients treat individual objects and compositions of objects uniformly. This is particularly useful when you need to work with a group of objects the same way you would a single instance.

This example models a graphic drawing application where simple shapes (like `Circle` and `Triangle`) can be grouped into more complex drawings. These complex objects (composites) can themselves be composed with other shapes or drawings, forming a nested hierarchy.

## Example Description

In our example, we implement the Composite pattern with the following components:

### Components

* **IShapeComponent (Component Interface)**
  Defines the common interface for all graphic objects. It declares a `Draw(string fillColor)` method that both simple shapes and composites must implement.

* **Circle & Triangle (Leaf Classes)**
  These are the simplest elements in the composition. Each implements the `Draw` method to render itself using the provided color.

* **Drawing (Composite Class)**
  The `Drawing` class is a composite that holds a collection of `IShapeComponent` instances. It can contain both leaves (e.g., `Circle`, `Triangle`) and other `Drawing` instances. Its `Draw` method delegates drawing behavior to each of its child components, effectively rendering the entire composition.

### Key Features

* **Uniform Treatment**: Whether a client is drawing a simple `Circle` or a complex `Drawing` composed of multiple shapes, it calls the same `Draw` method.
* **Recursive Composition**: The `Drawing` class can contain other `Drawing` objects, enabling a recursive hierarchy of shapes.
* **Encapsulation of Complexity**: Clients don’t need to distinguish between simple and complex shapes when using the composite interface.

## When to Use

* You want to represent part-whole hierarchies (e.g., graphics, UI trees, file systems).
* You want clients to treat individual objects and compositions uniformly.
* You want to simplify client code that works with complex tree structures.

## Benefits

* Simplifies client code.
* Makes it easier to add new types of components.
* Promotes flexibility and extensibility in managing tree structures.

## Drawbacks

* Can make the design overly general; it may be harder to restrict types in a composite.
* May lead to a design where leaves and composites have too many methods that don’t make sense for all children (e.g., `Clear()` on a `Circle`).

## Resources

Generated by ChatGPT
