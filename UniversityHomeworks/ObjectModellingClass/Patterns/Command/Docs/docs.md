# Command Design Pattern

The Command Design Pattern is a behavioral pattern that turns requests or simple operations into standalone objects.
This allows you to parameterize methods with different requests, delay or queue a request's execution,
and support undoable operations.

It encapsulates a request as an object, thereby allowing users to decouple the invoker of the request from the object that knows how to perform it.

## Real-World Analogy

Think of a **restaurant waiter**. When you (the client) order a dish, the waiter takes your order and brings it to the kitchen.
The waiter doesn't cook the meal - they simply deliver the order (command) to the chef (receiver), who knows how to prepare it.

This separation of responsibilities is what the Command pattern is all about.
The client only needs to know how to issue a command, not how it�s executed.

## Structure

```plaintext
Client ? Command ? Receiver
        ?
     Invoker
````

## Components

* **ICommand**: Interface that declares a method for executing a command.
* **ConcreteCommand**: Implements ICommand and defines a binding between the Receiver and the action.
* **Receiver**: The component that performs the actual work.
* **Invoker**: Triggers the command execution, potentially without knowing what the command does.
* **Client**: Configures commands and sets up invokers and receivers.

## When to Use

* You want to parameterize objects with actions to perform.
* You need to queue, log, or undo requests.
* You want to decouple the object invoking the operation from the one that knows how to perform it.
* You need support for macro commands (multiple commands executed together).

## Benefits

* Decouples the sender and receiver of a request.
* Supports undo/redo functionality.
* Makes it easy to implement logging or auditing.
* Enables dynamic command execution and queuing.

## Drawbacks

* May increase the number of classes significantly.
* Adds a layer of complexity due to extra indirection.

* Here’s a complete `README.md` file for your **Command Pattern – Stock Trading** example, written in a clear, educational, and structured format:

## Command Design Pattern Example – Stock Trading Example

This project demonstrates the **Command Design Pattern** using a simplified stock trading system.

The pattern encapsulates a request as an object, thereby allowing for parameterization of clients with different requests, queuing of requests, and support for undoable operations.

This example includes a `Broker` that accepts and executes stock-related orders (`Buy` or `Sell`), with each action encapsulated as a command object.

Think of a **stock broker**:
A client doesn’t interact directly with the stock exchange.
Instead, they issue **buy or sell orders** to the broker.
The broker queues and eventually executes those orders.
The client doesn’t need to know *how* the stock is bought or sold - just that the broker will take care of it.

### Participants in this pattern:

- **Command (`IOrder`)**: Declares an interface for executing operations.
- **Concrete Commands (`BuyStock`, `SellStock`)**: Implements the command interface and binds to a receiver.
- **Receiver (`Stock`)**: Knows how to perform the operation (e.g., buy/sell logic).
- **Invoker (`Broker`)**: Stores commands and triggers their execution.
- **Client**: Sets up the command objects and assigns them to the invoker.

```

Client --> Command (IOrder)
/     &#x20;
BuyStock  SellStock
\         /
Receiver: Stock
|
Invoker: Broker

```

### Components

- **`IOrder`**: Command interface declaring the `Execute()` method.
- **`BuyStock` / `SellStock`**: Concrete commands that call `Buy()` or `Sell()` on the receiver.
- **`Stock`**: Receiver class with the actual business logic for buying and selling.
- **`Broker`**: Invoker that stores orders and executes them on request via `PlaceOrders()`.

## Resources

Generated by ChatGPT
